# 🛡️ エラーハンドリング戦略（budget_book）

---

本ドキュメントでは、budget_bookにおけるエラーハンドリングの基本方針、実装戦略、およびユーザー体験に関する考え方を定義します。型安全性を重視したTypeScript+Zodの環境で、一貫したエラー処理とリカバリー手段を提供することを目指します。

---

## 📋 基本方針

- **早期検出と型安全性の確保**
  - Zodによるバリデーションを最前線に配置
  - TypeScriptの型システムを活用した静的型チェック
  - 実行時のエラーは可能な限り回避し、発生時は適切に捕捉

- **ユーザー体験を損なわない対応**
  - エラーメッセージは具体的かつ対応方法が明確なものに
  - 技術的な詳細よりも「次に何をすべきか」を優先
  - 可能な限りリカバリー手段を提供する

- **レイヤー別の責務分離**
  - UIレイヤー：フォームバリデーションとユーザーへの表示
  - アプリケーションレイヤー：ビジネスルール検証と例外変換
  - ドメインレイヤー：ドメインルールの保証とドメイン例外の発生
  - インフラレイヤー：外部依存のエラーをアプリケーション例外に変換

---

## 💼 エラー種別の階層

### 1. ValidationError（バリデーションエラー）

フォームデータやAPIリクエストなど、入力値の検証に関するエラー。

- **実装方針**：
  - フロントエンド：Zod+React Hookを用いたフォームバリデーション
  - バックエンド：Server Actions/API層でのZodスキーマ適用

- **表示方針**：
  - フィールド単位でのインラインエラーメッセージ
  - 修正方法を具体的に提示
  - 例：「金額は1円以上の数値を入力してください」

### 2. BusinessRuleError（業務ルールエラー）

データ自体は有効だが、業務ルール上許可されない操作に関するエラー。

- **実装例**：
  - 「返済額が貸付残高を超えている」
  - 「指定されたMethodはアーカイブ済みのため使用できない」
  - 「同じ日に同じ金額・目的の支出が既に登録されています」

- **表示方針**：
  - アラートやトースト通知でのエラー説明
  - 必要に応じて代替案の提示
  - 例：「この支払い方法は現在アーカイブされています。別の支払い方法を選択するか、設定から再有効化してください」

### 3. SystemError（システムエラー）

システム内部や外部連携の問題によるエラー。ユーザー操作では回避できない。

- **実装例**：
  - データベース接続エラー
  - 認証サービスの障害
  - ファイルシステムエラー

- **表示方針**：
  - 技術的詳細を最小限に抑えたエラーメッセージ
  - 「しばらく経ってから再試行」を促す
  - 必要に応じて自動リトライ機構を実装
  - 例：「システムの一時的な問題が発生しました。数分後にもう一度お試しください」

### 4. NotFoundError（存在しないリソース）

要求されたリソースが見つからない場合のエラー。

- **実装例**：
  - 存在しないEntryの編集を試みる
  - 削除済みのMethodを参照

- **表示方針**：
  - リダイレクトや代替表示
  - 明確な説明と次のステップの提案
  - 例：「指定されたエントリは削除されたか、存在しません。一覧に戻る」

---

## 🛠️ 実装戦略

### 1. 共通エラークラスの定義

```typescript
// shared/errors/AppError.ts
export abstract class AppError extends Error {
  constructor(
    message: string,
    public readonly code: string,
    public readonly httpStatus: number = 400,
    public readonly details?: unknown
  ) {
    super(message);
    this.name = this.constructor.name;
    Object.setPrototypeOf(this, new.target.prototype);
  }
}

export class ValidationError extends AppError {
  constructor(message: string, details?: Record<string, string[]>) {
    super(message, 'VALIDATION_ERROR', 400, details);
  }
}

export class BusinessRuleError extends AppError {
  constructor(message: string, code: string) {
    super(message, code, 400);
  }
}

export class NotFoundError extends AppError {
  constructor(resource: string, id?: string) {
    super(
      `${resource}${id ? ` (${id})` : ''}が見つかりません`,
      'RESOURCE_NOT_FOUND',
      404
    );
  }
}

export class SystemError extends AppError {
  constructor(message: string, originalError?: unknown) {
    super(
      message || 'システムエラーが発生しました',
      'SYSTEM_ERROR',
      500,
      originalError
    );
    // エラーログ記録など
  }
}
```

### 2. Zodバリデーションとエラー変換

```typescript
// shared/validation/validateWithSchema.ts
import { ZodSchema } from 'zod';
import { ValidationError } from '../errors/AppError';

export function validateWithSchema<T>(schema: ZodSchema<T>, data: unknown): T {
  const result = schema.safeParse(data);
  
  if (!result.success) {
    const formattedErrors: Record<string, string[]> = {};
    
    result.error.errors.forEach(err => {
      const path = err.path.join('.');
      if (!formattedErrors[path]) {
        formattedErrors[path] = [];
      }
      formattedErrors[path].push(err.message);
    });
    
    throw new ValidationError('入力内容に問題があります', formattedErrors);
  }
  
  return result.data;
}
```

### 3. フロントエンドでのエラーハンドリング（React）

```tsx
// フロントエンド実装例（Next.js App Router + React）
'use client';

import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { entrySchema } from '@/shared/zod/entrySchema';
import { useState } from 'react';
import { createEntry } from './actions';

export default function EntryForm() {
  const [serverError, setServerError] = useState<string | null>(null);
  
  const { register, handleSubmit, formState: { errors } } = useForm({
    resolver: zodResolver(entrySchema)
  });
  
  const onSubmit = async (data) => {
    try {
      setServerError(null);
      await createEntry(data);
      // 成功時の処理
    } catch (error) {
      if (error instanceof ValidationError) {
        // フォームエラーとして表示
        // react-hook-formのsetErrorなどで処理
      } else {
        // その他のエラー
        setServerError(error.message || 'エラーが発生しました');
      }
    }
  };
  
  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      {/* フォーム要素 */}
      
      {/* サーバーエラー表示 */}
      {serverError && (
        <div className="error-message">{serverError}</div>
      )}
      
      {/* フィールドエラー表示の例 */}
      <input {...register('amount')} />
      {errors.amount && (
        <span className="field-error">{errors.amount.message}</span>
      )}
      
      <button type="submit">保存</button>
    </form>
  );
}
```

### 4. サーバーサイド（Server Actions）でのエラーハンドリング

```typescript
// app/entry/actions.ts
'use server';

import { z } from 'zod';
import { entrySchema } from '@/shared/zod/entrySchema';
import { validateWithSchema } from '@/shared/validation/validateWithSchema';
import { BusinessRuleError, NotFoundError, SystemError } from '@/shared/errors/AppError';
import { createEntryUseCase } from '@/modules/entry/application/usecases/createEntry';

export async function createEntry(formData: FormData | Record<string, unknown>) {
  try {
    // 1. バリデーション
    const data = validateWithSchema(entrySchema, formData);
    
    // 2. ユースケース実行
    await createEntryUseCase(data);
    
    return { success: true };
  } catch (error) {
    // エラータイプに応じた適切な処理
    if (
      error instanceof BusinessRuleError ||
      error instanceof NotFoundError ||
      error instanceof ValidationError
    ) {
      // 既知のビジネスエラーはそのまま上位に伝搬
      throw error;
    }
    
    // 未知のエラーはSystemErrorに変換してログ出力
    console.error('Unexpected error in createEntry:', error);
    throw new SystemError(
      'エントリーの登録中にエラーが発生しました。しばらく経ってからもう一度お試しください。'
    );
  }
}
```

---

## 🎨 UI実装におけるエラー表示方針

### 1. フォームバリデーションエラー

- **インライン表示**: フィールド直下に赤色テキストで表示
- **サブミット防止**: エラーがある場合はボタンを無効化またはサブミットをブロック
- **即時フィードバック**: 可能な限りブラー時やタイピング中に検証

### 2. ビジネスルールエラー

- **トースト通知**: 画面上部または右上にトーストで表示
- **フォームエラー**: 関連フィールドの近くに追加説明として表示
- **代替案提示**: 可能な場合は対処方法や代替案を示す

### 3. システムエラー

- **モーダルまたはトースト**: 致命的な場合はモーダル、それ以外はトースト
- **リトライ機能**: 可能な操作には自動または手動リトライボタンを提供
- **一時的エラーの区別**: ネットワークエラーなど一時的な問題は別途扱い

### 4. 404エラー

- **専用ページ**: アプリ全体のスタイルに合った404ページ
- **ナビゲーション提案**: ホームや関連ページへのリンク提供
- **検索機能**: 可能であれば検索ボックスを表示

---

## 🔍 ロギング戦略

### 1. クライアントサイドログ

- **開発環境**: 詳細ログ（Redux DevTools、React Query Devtoolsなど）
- **本番環境**: 最小限の重要なエラーログ（セキュリティに配慮）
- **エラーバウンダリ**: React Error Boundaryによる致命的UI崩壊の防止

### 2. サーバーサイドログ

- **構造化ログ**: JSON形式で記録
- **エラーレベル分け**: ERROR / WARN / INFOの適切な区分
- **コンテキスト付加**: ユーザー操作、リクエストID、関連データのサマリ
- **PII除去**: 個人情報や機密データは記録前にマスク

### 3. エラー監視

- **未処理例外の捕捉**: グローバルエラーハンドラの設定
- **パターン検出**: 繰り返し発生するエラーの識別と優先対応

---

## 📱 モバイル対応と通信エラー

### 1. オフライン対応

- **エラーメッセージ**: オフラインであることを明示
- **データキャッシュ**: 可能な操作はオフラインでも実行可能に
- **自動再試行**: オンラインに復帰した際の同期機能

### 2. ネットワークエラー

- **タイムアウト設定**: 適切なAPIタイムアウト値の設定
- **再試行戦略**: 指数バックオフによる再試行
- **部分的UI更新**: ネットワークエラー時も使用可能なUI要素は維持

---

## 📬 エラー報告と分析

### 1. エラー報告メカニズム

- **フィードバックUI**: エラー画面からのフィードバック送信機能
- **エラーコンテキスト**: 再現手順やエラー状況の自動収集

### 2. エラー分析

- **優先度判定**: 発生頻度と影響度に基づく対応優先度の決定
- **パターン分析**: 特定条件下で頻発するエラーの特定
- **改善サイクル**: 分析結果に基づくバグ修正と機能改善

---

この戦略は、budget_bookの開発と運用を通じて継続的に改善・拡張されるべきものです。型安全性を基盤としながら、常にユーザー体験を最優先に考慮したエラーハンドリングを目指します。
